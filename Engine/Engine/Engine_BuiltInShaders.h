#pragma once
#ifndef ENGINE_BUILTINSHADERS_H
#define ENGINE_BUILTINSHADERS_H

#include <string>

namespace Engine{
    namespace Shaders{
        namespace Detail{
            class ShadersManagement{
                private:
                public:
                    static std::string fullscreen_quad_vertex;
                    static std::string vertex_basic;
                    static std::string vertex_hud;
                    static std::string vertex_skybox;

                    static std::string smaa_vertex_1;
                    static std::string smaa_frag_1;

                    static std::string smaa_vertex_2;
                    static std::string smaa_frag_2;

                    static std::string smaa_vertex_3;
                    static std::string smaa_frag_3;

                    static std::string smaa_vertex_4;
                    static std::string smaa_frag_4;

                    static std::string fxaa_frag;

                    static std::string deferred_frag;
                    static std::string deferred_frag_hud;
                    static std::string deferred_frag_skybox;

                    static std::string copy_depth_frag;

                    static std::string ssao_frag;
                    static std::string hdr_frag;
                    static std::string godRays_frag;
                    static std::string blur_frag;
                    static std::string edge_frag;
                    static std::string final_frag;
                    static std::string lighting_frag;
            };
        };
    };
};

#pragma region FullscreenQuadVertex
std::string Engine::Shaders::Detail::ShadersManagement::fullscreen_quad_vertex =
    "#version 120\n"
    "\n"
    "uniform mat4 VP;\n"
    "uniform mat4 Model;\n"
    "\n"
    "void main(void){\n"
    "    mat4 MVP = VP * Model;\n"
    "    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
    "    gl_Position = MVP * gl_Vertex;\n"
    "}";
#pragma endregion

#pragma region VertexBasic
std::string Engine::Shaders::Detail::ShadersManagement::vertex_basic =
    "#version 120\n"
    "\n"
    "attribute vec3 position;\n"
    "attribute vec2 uv;\n"
    "attribute vec3 normal;\n"
    "attribute vec3 binormal;\n"
    "attribute vec3 tangent;\n"
    "attribute vec4 BoneIDs;\n"
    "attribute vec4 Weights;\n"
    "\n"
    "uniform mat4 VP;\n"
    "uniform mat4 Model;\n"
    "uniform mat3 NormalMatrix;\n"
    "uniform int AnimationPlaying;\n"
    "uniform mat4 gBones[200];\n"
    "\n"
    "varying vec2 UV;\n"
    "\n"
    "varying vec3 Normals;\n"
    "varying vec3 Binormals;\n"
    "varying vec3 Tangents;\n"
    "varying vec3 WorldPosition;\n"
    "\n"
    "varying float logz_f;\n"
    "varying float FC_2_f;\n"
    "uniform float fcoeff;\n"
    "\n"
    "void main(void){\n"
    "	mat4 BoneTransform = mat4(1.0);\n"
    "	if(AnimationPlaying == 1.0){\n"
    "		BoneTransform  = gBones[int(BoneIDs.x)] * Weights.x;\n"
    "		BoneTransform += gBones[int(BoneIDs.y)] * Weights.y;\n"
    "		BoneTransform += gBones[int(BoneIDs.z)] * Weights.z;\n"
    "		BoneTransform += gBones[int(BoneIDs.w)] * Weights.w;\n"
    "	}\n"
    "	vec4 PosTransformed = BoneTransform * vec4(position, 1.0);\n"
    "	vec4 NormalTransformed = BoneTransform * vec4(normal, 0.0);\n"
    "	vec4 BinormalTransformed = BoneTransform * vec4(binormal, 0.0);\n"
    "	vec4 TangentTransformed = BoneTransform * vec4(tangent, 0.0);\n"
    "\n"
    "	mat4 MVP = VP * Model;\n"
    "\n"
    "	gl_Position = MVP * PosTransformed;\n"
    "\n"
    "	Normals = (NormalMatrix * NormalTransformed.xyz).xyz;\n"
    "	Binormals = (NormalMatrix * BinormalTransformed.xyz).xyz;\n"
    "	Tangents = (NormalMatrix * TangentTransformed.xyz).xyz;\n"
    "\n"
    "	WorldPosition = (Model * PosTransformed).xyz;\n"
    "\n"
    "	UV = uv;\n"
    "	logz_f = 1.0 + gl_Position.w;\n"
    "	gl_Position.z = (log2(max(1e-6, logz_f)) * fcoeff - 1.0) * gl_Position.w;\n"
    "	FC_2_f = fcoeff * 0.5;\n"
    "}";

#pragma endregion

#pragma region VertexHUD
std::string Engine::Shaders::Detail::ShadersManagement::vertex_hud =
    "#version 120\n"
    "\n"
    "attribute vec3 position;\n"
    "attribute vec2 uv;\n"
    "attribute vec3 normal;\n"
    "attribute vec3 binormal;\n"
    "attribute vec3 tangent;\n"
    "\n"
    "uniform mat4 VP;\n"
    "uniform mat4 Model;\n"
    "\n"
    "varying vec2 UV;\n"
    "\n"
    "void main(void){\n"
    "	mat4 MVP = VP * Model;\n"
    "	UV = uv;\n"
    "	gl_Position = MVP * vec4(position, 1.0);\n"
    "\n"
    "	gl_TexCoord[6] = gl_Position;\n"
    "}";

#pragma endregion

#pragma region VertexSkybox
std::string Engine::Shaders::Detail::ShadersManagement::vertex_skybox =
    "#version 120\n"
    "\n"
    "attribute vec3 position;\n"
    "uniform mat4 VP;\n"
    "uniform mat4 Model;\n"
    "\n"
    "varying vec3 UV;\n"
    "\n"
    "void main(void){\n"
    "	mat4 MVP = VP * Model;\n"
    "	UV = position;\n"
    "	gl_Position = MVP * vec4(position, 1.0);\n"
    "	gl_Position.z = gl_Position.w;\n"
    "}";
#pragma endregion

#pragma region FXAA
std::string Engine::Shaders::Detail::ShadersManagement::fxaa_frag = 
    "#version 120\n"
    "#define FXAA_REDUCE_MIN (1.0/128.0)\n"
    "#define FXAA_REDUCE_MUL (1.0/8.0)\n"
    "#define FXAA_SPAN_MAX 8.0\n"
    "uniform sampler2D sampler0;\n"
    "uniform vec2 resolution;\n"
    "\n"
    "void main(void){\n"
    "   vec2 uv = gl_TexCoord[0].st;\n"
    "\n"
    "   vec2 inverse_resolution = vec2(1.0/resolution.x, 1.0/resolution.y);\n"
    "   vec3 rgbNW = texture2D(sampler0, uv + (vec2(-1.0,-1.0)) * inverse_resolution).xyz;\n"
    "   vec3 rgbNE = texture2D(sampler0, uv + (vec2(1.0,-1.0)) * inverse_resolution).xyz;\n"
    "   vec3 rgbSW = texture2D(sampler0, uv + (vec2(-1.0,1.0)) * inverse_resolution).xyz;\n"
    "   vec3 rgbSE = texture2D(sampler0, uv + (vec2(1.0,1.0)) * inverse_resolution).xyz;\n"
    "   vec3 rgbM  = texture2D(sampler0,  uv).xyz;\n"
    "   vec3 luma = vec3(0.299, 0.587, 0.114);\n"
    "   float lumaNW = dot(rgbNW, luma);\n"
    "   float lumaNE = dot(rgbNE, luma);\n"
    "   float lumaSW = dot(rgbSW, luma);\n"
    "   float lumaSE = dot(rgbSE, luma);\n"
    "   float lumaM  = dot(rgbM,  luma);\n"
    "   float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
    "   float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE))); \n"
    "   vec2 dir;\n"
    "   dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
    "   dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
    "   float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),FXAA_REDUCE_MIN);\n"
    "   float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
    "   dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),dir * rcpDirMin)) * inverse_resolution;\n"
    "   vec3 rgbA = 0.5 * (texture2D(sampler0, uv   + dir * (1.0/3.0 - 0.5)).xyz + texture2D(sampler0, uv   + dir * (2.0/3.0 - 0.5)).xyz);\n"
    "   vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(sampler0,  uv   + dir *  - 0.5).xyz + texture2D(sampler0,  uv   + dir * 0.5).xyz);\n"
    "   float lumaB = dot(rgbB, luma);\n"
    "\n"
    "   if((lumaB < lumaMin) || (lumaB > lumaMax)) {\n"
    "       gl_FragColor = vec4(rgbA,1.0);\n"
    "   }\n"
    "   else{\n"
    "       gl_FragColor = vec4(rgbB,1.0);\n"
    "   }\n"
    "}";
#pragma endregion

#pragma region DeferredFrag
std::string Engine::Shaders::Detail::ShadersManagement::deferred_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D DiffuseTexture;\n"
	"uniform sampler2D NormalTexture;\n"
	"uniform sampler2D GlowTexture;\n"
	"uniform sampler2D SpecularTexture;\n"
	"\n"
	"uniform sampler2D AOTexture;\n"
	"uniform sampler2D MetalnessTexture;\n"
	"uniform sampler2D SmoothnessTexture;\n"
	"uniform float BaseAO;\n"
	"uniform float BaseMetalness;\n"
	"uniform float BaseSmoothness;\n"
    "\n"
	"uniform samplerCube ReflectionTexture;\n"
	"uniform sampler2D   ReflectionTextureMap;\n"
	"uniform samplerCube RefractionTexture;\n"
	"uniform sampler2D   RefractionTextureMap;\n"
    "\n"
	"uniform float       CubemapMixFactor;\n"
	"uniform float       RefractiveIndex;\n"
	"uniform vec3        CameraPosition;\n"
    "\n"
	"uniform float BaseGlow;\n"
	"uniform float matID;\n"
    "\n"
	"uniform int Shadeless;\n"
	"uniform int HasGodsRays;\n"
    "\n"
	"uniform vec3 FirstConditionals;  //x = diffuse  y = normals    z = glow\n"
	"uniform vec3 SecondConditionals; //x = specular y = reflection z = refraction\n"
	"uniform vec3 ThirdConditionals; //x = ao y = metalness z = smoothness\n"
	"\n"
	"uniform vec4 Object_Color;\n"
	"uniform vec3 Gods_Rays_Color;\n"
	"\n"
	"varying vec3 WorldPosition;\n"
	"varying vec2 UV;\n"
	"varying vec3 Normals;\n"
	"varying vec3 Binormals;\n"
	"varying vec3 Tangents;\n"
	"\n"
	"varying float FC_2_f;\n"
	"varying float logz_f;\n"
    "\n"
	"vec4 PaintersAlgorithm(vec4 paint, vec4 canvas){\n"
	"	vec4 r = vec4(0.0);\n"
	"	float Alpha = paint.a + canvas.a * (1.0 - paint.a);\n"
	"	r.r = (paint.r * paint.a + canvas.r * canvas.a * (1.0-paint.a)) / Alpha;\n"
	"	r.g = (paint.g * paint.a + canvas.g * canvas.a * (1.0-paint.a)) / Alpha;\n"
	"	r.b = (paint.b * paint.a + canvas.b * canvas.a * (1.0-paint.a)) / Alpha;\n"
	"	r.a = Alpha;\n"
	"	return r;\n"
	"}\n"
	"vec4 Reflection(vec4 d, vec3 cpos, vec3 n, vec3 wpos){\n"
	"	vec4 r = vec4(0.0);\n"
	"	r = textureCube(ReflectionTexture,reflect(n,normalize(cpos - wpos))) * texture2D(ReflectionTextureMap,UV).r;\n"
	"	r.a *= CubemapMixFactor;\n"
	"	r = PaintersAlgorithm(r,d);\n"
	"	return r;\n"
	"}\n"
	"vec4 Refraction(vec4 d, vec3 cpos, vec3 n, vec3 wpos){\n"
	"	vec4 r = vec4(0.0);\n"
	"	r = textureCube(RefractionTexture,refract(n,normalize(cpos - wpos),1.0 / RefractiveIndex)) * texture2D(RefractionTextureMap,UV).r;\n"
	"	r.a *= CubemapMixFactor;\n"
	"	r = PaintersAlgorithm(r,d);\n"
	"	return r;\n"
	"}\n"
    "\n"
	"vec3 CalcBumpedNormal(void){\n"
	"	vec3 normTexture = texture2D(NormalTexture, UV).xyz;\n"
	"	vec3 t = (normTexture * 2.0) - 1.0;\n"
	"	mat3 TBN = mat3(Tangents, Binormals, Normals);\n"
	"	return normalize(TBN * t);\n"
	"}\n"
	"void main(void){\n"
	"	gl_FragData[0] = Object_Color;\n"
	"	gl_FragData[1].rgb = normalize(Normals);\n"
	"	gl_FragData[2].r = BaseGlow;\n"
	"	gl_FragData[2].g = 1.0;\n"
	"	gl_FragData[2].b = BaseMetalness;\n"
	"	gl_FragData[1].a = matID;\n"
    "\n"
	"	if(FirstConditionals.x > 0.5){ gl_FragData[0] *= texture2D(DiffuseTexture, UV); }\n"
	"	if(FirstConditionals.y > 0.5){ gl_FragData[1].rgb = CalcBumpedNormal(); }\n"
    "\n"
	"	if(SecondConditionals.y > 0.5){\n"
	"		gl_FragData[0] = Reflection(gl_FragData[0],CameraPosition,gl_FragData[1].rgb,WorldPosition);\n"
	"	}\n"
    "\n"
	"	if(SecondConditionals.z > 0.5){\n"
	"		gl_FragData[0] = Refraction(gl_FragData[0],CameraPosition,gl_FragData[1].rgb,WorldPosition);\n"
	"	}\n"
	"	if(ThirdConditionals.z > 0.5){\n"
	"		gl_FragData[2].b = BaseSmoothness * texture2D(MetalnessTexture, UV).r;\n"
	"	}\n"
    "\n"
	"	if(Shadeless == 0){\n"
	"		if(FirstConditionals.z > 0.5){ \n"
	"			gl_FragData[2].r += texture2D(GlowTexture, UV).r; \n"
	"		}\n"
	"		if(SecondConditionals.x > 0.5){ \n"
	"			gl_FragData[2].g = texture2D(SpecularTexture, UV).r; \n"
	"		}\n"
	"	}\n"
	"	else{ \n"
	"		gl_FragData[1].rgb = vec3(1.0); \n"
	"	}\n"
	"\n"
	"	if(HasGodsRays == 1){\n"
	"		gl_FragData[3] = (texture2D(DiffuseTexture, UV) * vec4(Gods_Rays_Color,1.0))*0.5;\n"
	"	}\n"
	"	gl_FragDepth = log2(logz_f) * FC_2_f;\n"
	"}";

#pragma endregion

#pragma region DeferredFragHUD
std::string Engine::Shaders::Detail::ShadersManagement::deferred_frag_hud = 
	"#version 120\n"
	"\n"
	"uniform sampler2D DiffuseTexture;\n"
	"uniform int DiffuseTextureEnabled;\n"
	"uniform vec4 Object_Color;\n"
	"\n"
	"varying vec2 UV;\n"
	"\n"
	"void main(void){\n"
	"	gl_FragData[0] = Object_Color;\n"
    "\n"
	"	if(DiffuseTextureEnabled == 1){\n"
	"		gl_FragData[0] *= texture2D(DiffuseTexture, UV);\n"
	"	}\n"
	"	gl_FragData[1].rgb = vec3(1.0);\n"
	"	gl_FragData[2].r = 0.0;\n"
	"	gl_FragData[2].b = 0.0;\n"
	"}";

#pragma endregion

#pragma region DeferredFragSkybox
std::string Engine::Shaders::Detail::ShadersManagement::deferred_frag_skybox = 
	"#version 120\n"
    "\n"
	"uniform samplerCube Texture;\n"
	"\n"
	"varying vec3 UV;\n"
	"varying vec3 WorldPosition;\n"
	"\n"
	"uniform int HasGodsRays;\n"
    "\n"
	"void main(void){\n"
	"	gl_FragData[0] = textureCube(Texture, UV);\n"
	"	gl_FragData[1].rgb = vec3(1.0);\n"
	"	gl_FragData[2].r = 0.0;\n"
	"	gl_FragData[2].b = 0.0;\n"
	"	if(HasGodsRays == 1){\n"
	"		gl_FragData[3] = vec4(0.0259,0.0224,0.0290,1.0);\n"
	"	} \n"
	"	gl_FragDepth = 0.99999;\n"
	"}";

#pragma endregion

#pragma region CopyDepthFrag
std::string Engine::Shaders::Detail::ShadersManagement::copy_depth_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D gDepthMap;\n"
	"\n"
	"void main(void){\n"
	"	vec2 uv = gl_TexCoord[0].st;\n"
	"	gl_FragDepth = texture2D(gDepthMap,uv);\n"
	"}";
#pragma endregion

#pragma region SSAO
std::string Engine::Shaders::Detail::ShadersManagement::ssao_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D gNormalMap;\n"
	"uniform sampler2D gRandomMap;\n"
	"uniform sampler2D gMiscMap;\n"
	"uniform sampler2D gLightMap;\n"
	"uniform sampler2D gDepthMap;\n"
	"\n"
	"uniform int doSSAO;\n"
	"uniform int doBloom;\n"
	"\n"
	"uniform vec3 CameraPosition;\n"
	"\n"
	"uniform vec4 SSAOInfo; //x - radius | y - intensity | z - bias | w - scale\n"
	"\n"
	"uniform int Samples;\n"
	"uniform int NoiseTextureSize;\n"
	"\n"
	"uniform vec2 poisson[32];\n"
    "\n"
	"uniform mat4 invVP;\n"
	"uniform float nearz;\n"
	"uniform float farz;\n"
    "\n"
	"vec3 reconstruct_world_pos(vec2 _uv){\n"
	"	float log_depth = texture2D(gDepthMap, _uv).r;\n"
	"	float regularDepth = pow(farz + 1.0, log_depth) - 1.0; //log to regular depth\n"
	"\n"
	"	//linearize regular depth\n"
	"	float a = farz / (farz - nearz);\n"
	"	float b = farz * nearz / (nearz - farz);\n"
	"	float depth = (a + b / regularDepth);\n"
    "\n"
	"	//vec4 screenSpace = vec4(_uv * 2.0 - 1.0,depth,1.0);\n"
	"	vec4 screenSpace = (vec4(_uv,depth, 1.0) * 2.0 - 1.0);\n"
	"\n"
	"	//world space it!\n"
	"	vec4 wpos = invVP * screenSpace;\n"
	"	return wpos.xyz / wpos.w;\n"
	"}\n"
	"float occlude(vec2 uv, vec2 offsetUV, vec3 origin, vec3 normal){\n"
	"	vec3 diff = (reconstruct_world_pos(uv + offsetUV)) - origin;\n"
	"	vec3 vec = normalize(diff);\n"
	"	float dist = length(diff) * SSAOInfo.w;\n"
	"	return max(0.0, dot(normal,vec) - SSAOInfo.z) * (1.0 / (1.0 + dist)) * SSAOInfo.y;\n"
	"}\n"
	"void main(void){\n"
	"	vec2 uv = gl_TexCoord[0].st * 2.0;\n"
	"	vec3 worldPosition = reconstruct_world_pos(uv);\n"
	"	vec3 normal = texture2D(gNormalMap, uv).xyz;\n"
	"	vec2 randomVector = normalize(texture2D(gRandomMap, gl_TexCoord[0].st / NoiseTextureSize).xy * 2.0 - 1.0);\n"
	"\n"
	"	float dist = distance(worldPosition, CameraPosition) + 0.0001; //cuz we dont like divide by zeros ;)\n"
	"	float rad = max(0.35,SSAOInfo.x / dist); //not having max 0.35, etc will make this behave very badly when zoomed far out\n"
    "\n"
	"	if(doSSAO == 1){\n"
	"		if(normal.r > 0.9999 && normal.g > 0.9999 && normal.b > 0.9999){ gl_FragColor.a = 1.0; }\n"
	"		else{\n"
	"			float occlusion = 0.0;\n"
	"			for (int i = 0; i < Samples; ++i) {\n"
	"				vec2 coord1 = reflect(poisson[i], randomVector)*rad;\n"
	"				vec2 coord2 = vec2(coord1.x*0.707 - coord1.y*0.707, coord1.x*0.707 + coord1.y*0.707);\n"
	"				occlusion += occlude(uv, coord1 * 0.25, worldPosition, normal);\n"
	"				occlusion += occlude(uv, coord2 * 0.50, worldPosition, normal);\n"
	"				occlusion += occlude(uv, coord1 * 0.75, worldPosition, normal);\n"
	"				occlusion += occlude(uv, coord2, worldPosition, normal);\n"
	"			}\n"
	"			occlusion /= (Samples*4.0);\n"
	"			gl_FragColor.a = 1.0-occlusion;\n"
	"		}\n"
	"	}\n"
	"	else{\n"
	"		gl_FragColor.a = 1.0;\n"
	"	}\n"
	"	if(doBloom == 1){\n"
	"		float Glow = texture2D(gMiscMap,uv).r;\n"
	"		vec3 lighting = texture2D(gLightMap,uv).rgb;\n"
	"		float brightness = dot(lighting, vec3(0.2126, 0.7152, 0.0722));\n"
	"		if(brightness > 1.3 || Glow > 0.01f){\n"
	"			float brightScale = log(brightness) * 0.7;\n"
	"			float glowScale = Glow * 0.73;\n"
	"			float scale = max(glowScale, brightScale);\n"
	"			gl_FragColor.rgb = (lighting * scale * scale);\n"
	"		}\n"
	"	}\n"
	"	else{\n"
	"		gl_FragColor.rgb = vec3(0.0);\n"
	"	}\n"
	"}";

#pragma endregion

#pragma region HDR
std::string Engine::Shaders::Detail::ShadersManagement::hdr_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D lightingBuffer;\n"
	"uniform sampler2D bloomBuffer;\n"
	"uniform sampler2D gDiffuseMap;\n"
	"uniform sampler2D gNormalMap;\n"
	"\n"
	"uniform vec4 HDRInfo; // exposure | HasHDR | HasBloom | HDRAlgorithm\n"
    "\n"
	"vec3 uncharted(vec3 x,float a,float b,float c,float d,float e,float f){\n"
	"	return vec3(((x*(a*x+c*b)+d*e)/(x*(a*x+b)+d*f))-e/f);\n"
	"}\n"
    "\n"
	"void main(void){\n"
	"	vec2 uv = gl_TexCoord[0].st;\n"
	"	vec3 diffuse = texture2D(gDiffuseMap,uv).rgb;\n"
	"	vec3 lighting = texture2D(lightingBuffer, uv).rgb;\n"
	"	vec3 bloom = texture2D(bloomBuffer, uv).rgb;\n"
	"	vec3 normals = texture2D(gNormalMap,uv).rgb;\n"
    "\n"
	"	if(normals.r > 0.999 && normals.g > 0.999 && normals.b > 0.999){\n"
	"		lighting = diffuse;\n"
	"	}\n"
	"	else{\n"
	"		if(HDRInfo.z == 1.0){\n"
	"			lighting += (diffuse * bloom);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if(HDRInfo.y == 1.0){\n"
	"		if(HDRInfo.w == 0.0){ // Reinhard tone mapping\n"
	"			lighting = lighting / (lighting + vec3(1.0));\n"
	"		}\n"
	"		else if(HDRInfo.w == 1.0){ //Filmic tone mapping\n"
	"			vec3 x = max(vec3(0), lighting - vec3(0.004));\n"
	"			lighting = (x * (vec3(6.2) * x + vec3(0.5))) / (x * (vec3(6.2) * x + vec3(1.7)) + vec3(0.06));\n"
	"		}\n"
	"		else if(HDRInfo.w == 2.0){ // Exposure tone mapping\n"
	"			lighting = vec3(1.0) - exp(-lighting * HDRInfo.x);\n"
	"		}\n"
	"		else if(HDRInfo.w == 3.0){ // Uncharted tone mapping\n"
	"			float A = 0.15; float B = 0.5; float C = 0.1; float D = 0.2; float E = 0.02; float F = 0.3; float W = 11.2;\n"
	"			lighting = HDRInfo.x * uncharted(lighting,A,B,C,D,E,F);\n"
	"			vec3 white = 1.0 / uncharted( vec3(W),A,B,C,D,E,F );\n"
	"			lighting *= white;\n"
	"		}\n"
	"	}\n"
	"	gl_FragColor = vec4(lighting, 1.0);\n"
	"}";

#pragma endregion

#pragma region Blur
std::string Engine::Shaders::Detail::ShadersManagement::blur_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D texture;\n"
	"uniform vec4 RGBA;\n"
	"uniform vec2 HV;\n"
	"\n"
	"vec2 offset[14];\n"
	"\n"
	"uniform float radius;\n"
	"uniform vec4 strengthModifier;\n"
    "\n"
	"float weights[7] = float[](0.028,0.024,0.020,0.016,0.012,0.008,0.004);\n"
	"\n"
	"float gauss[7] = float[](\n"
	"	0.0044299121055113265,\n"
	"	0.00895781211794,\n"
	"	0.0215963866053,\n"
	"	0.0443683338718,\n"
	"	0.0776744219933,\n"
	"	0.115876621105,\n"
	"	0.147308056121\n"
	");\n"
	"void main(void){\n"
	"	for(int i = 0; i < 7; i++){\n"
	"		offset[i] = vec2(-weights[i] * radius * HV.x, -weights[i] * radius * HV.y);\n"
	"		offset[13-i] = vec2(weights[i] * radius * HV.x, weights[i] * radius * HV.y);\n"
	"	}\n"
	"	vec4 sum = vec4(0.0);\n"
	"	vec2 uv = gl_TexCoord[0].st * 2.0;\n"
	"\n"
	"	float strengthR = max(1.0, radius * strengthModifier.r);\n"
	"	float strengthG = max(1.0, radius * strengthModifier.g);\n"
	"	float strengthB = max(1.0, radius * strengthModifier.b);\n"
	"	float strengthA = max(1.0, radius * strengthModifier.a);\n"
	"	vec4 strength = vec4(strengthR,strengthG,strengthB,strengthA);\n"
	"	for(int i = 0; i < 7; i++){\n"
	"		sum += texture2D(texture, uv + offset[i])    * gauss[i] * strength;\n"
	"		sum += texture2D(texture, uv + offset[13-i]) * gauss[i] * strength;\n"
	"	}\n"
	"	sum.r += texture2D(texture, uv ).r * 0.159576912161 * strengthR;\n"
	"	sum.g += texture2D(texture, uv ).g * 0.159576912161 * strengthG;\n"
	"	sum.b += texture2D(texture, uv ).b * 0.159576912161 * strengthB;\n"
	"	sum.a += texture2D(texture, uv ).a * 0.159576912161 * strengthA;\n"
	"\n"
	"	if(RGBA.x == 1.0) gl_FragColor.r = sum.r;\n"
	"	if(RGBA.y == 1.0) gl_FragColor.g = sum.g;\n"
	"	if(RGBA.z == 1.0) gl_FragColor.b = sum.b;\n"
	"	if(RGBA.w == 1.0) gl_FragColor.a = sum.a;\n"
	"}";

#pragma endregion

#pragma region GodRays
std::string Engine::Shaders::Detail::ShadersManagement::godRays_frag = 
	"#version 120\n"
	"\n"
	"uniform vec4 RaysInfo; //exposure | decay | density | weight\n"
	"\n"
	"uniform vec2 lightPositionOnScreen;\n"
	"uniform sampler2D firstPass;\n"
	"uniform int samples;\n"
	"\n"
	"uniform int behind;\n"
	"uniform float alpha;\n"
	"\n"
	"void main(void){\n"
	"	if(behind == 0){\n"
	"		vec2 uv = gl_TexCoord[0].st*2.0;\n"
	"		vec2 deltaUV = vec2(uv - lightPositionOnScreen);\n"
	"		deltaUV *= 1.0 /  float(samples) * RaysInfo.z;\n"
    "\n"
	"		float illuminationDecay = 1.0;\n"
	"		for(int i=0; i < samples; i++){\n"
	"			uv -= deltaUV / 2.0;\n"
	"\n"
	"			vec4 sample = texture2D(firstPass,uv);  \n"
	"			sample *= illuminationDecay * RaysInfo.w;\n"
	"			gl_FragColor += (sample * alpha);\n"
	"			illuminationDecay *= RaysInfo.y;\n"
	"		}\n"
	"		gl_FragColor *= RaysInfo.x;\n"
	"	}\n"
	"}";

#pragma endregion

#pragma region EdgeDetect
std::string Engine::Shaders::Detail::ShadersManagement::edge_frag = 
	"#version 120\n"
	"\n"
	"uniform vec2 gScreenSize;\n"
	"uniform sampler2D texture;\n"
	"uniform float radius;\n"
    "\n"
	"float threshold(float thr1,float thr2 ,float val) {\n"
	"	if (val < thr1) { return 0.0; }\n"
	"	if (val > thr2) { return 1.0; }\n"
	"	return val;\n"
	"}\n"
	"\n"
	"// averaged pixel intensity from 3 color channels\n"
	"float avg_intensity(vec4 pix) {\n"
	"	return (pix.r + pix.g + pix.b)/3.0;\n"
	"}\n"
	"vec4 get_pixel(vec2 coords,float dx,float dy) {\n"
	"	float value = texture2D(texture,coords + vec2(dx, dy)).r;\n"
	"	return vec4(value);\n"
	"}\n"
	"float IsEdge(vec2 coords){\n"
	"	float dxtex = 1.0 / gScreenSize.x;\n"
	"	float dytex = 1.0 / gScreenSize.y;\n"
	"	float pix[9];\n"
	"	int k = -1;\n"
	"	float delta;\n"
    "\n"
	"	// read neighboring pixel intensities\n"
	"	for (int i=-1; i<2; i++) {\n"
	"		for(int j=-1; j<2; j++) {\n"
	"			k++;\n"
	"			pix[k] = avg_intensity(get_pixel(coords,float(i)*dxtex,float(j)*dytex));\n"
	"		}\n"
	"	}\n"
	"	// average color differences around neighboring pixels\n"
	"	delta = (abs(pix[1]-pix[7])+abs(pix[5]-pix[3]) +abs(pix[0]-pix[8])+abs(pix[2]-pix[6]))/2.0;\n"
	"	return threshold(0.15,0.6,clamp(1.8*delta,0.0,1.0));\n"
	"}\n"
	"void main(void){\n"
	"	vec2 uv = gl_TexCoord[0].st;\n"
	"	float edge = IsEdge(gl_TexCoord[0].xy);\n"
	"	gl_FragColor = vec4(edge);\n"
	"}";
#pragma endregion

#pragma region FinalFrag
std::string Engine::Shaders::Detail::ShadersManagement::final_frag = 
	"#version 120\n"
	"\n"
	"uniform sampler2D gDiffuseMap;\n"
	"uniform sampler2D gLightMap;\n"
	"uniform sampler2D gMiscMap;\n"
	"uniform sampler2D gGodsRaysMap;\n"
	"uniform sampler2D gBloomMap;\n"
    "\n"
	"uniform int HasSSAO;\n"
	"uniform int HasLighting;\n"
	"uniform int HasHDR;\n"
	"\n"
	"uniform float gamma;\n"
    "\n"
	"void main(void){\n"
	"	vec2 uv = gl_TexCoord[0].st;\n"
	"	vec3 diffuse = texture2D(gDiffuseMap, uv).rgb;\n"
	"	vec3 rays = texture2D(gGodsRaysMap,uv).rgb;\n"
	"	vec3 hdr = texture2D(gMiscMap,uv).rgb;\n"
	"	vec3 lighting = texture2D(gLightMap, uv).rgb;\n"
	"\n"
	"	if(HasLighting == 0){ \n"
	"		lighting = diffuse;\n"
	"	}\n"
	"	else{\n"
	"		lighting = hdr;\n"
	"	}\n"
	"	if(HasSSAO == 1){ \n"
	"		float brightness = dot(lighting, vec3(0.2126, 0.7152, 0.0722));\n"
	"		float ssao = texture2D(gBloomMap,uv).a + 0.0001;\n"
	"		brightness = min(1.0,pow(brightness,0.125));\n"
	"		lighting *= max(brightness, ssao);\n"
	"	}\n"
	"	lighting += rays;\n"
	"	//lighting = pow(lighting, vec3(1.0 / gamma));\n"
	"	gl_FragColor = vec4(lighting,1.0);\n"
	"}";

#pragma endregion

#pragma region LightingFrag
std::string Engine::Shaders::Detail::ShadersManagement::lighting_frag = 
	"#version 120\n"
	"#define MATERIAL_COUNT_LIMIT 255\n"
	"\n"
	"uniform vec4 LightDataA;\n" //x = ambient, y = diffuse, z = specular, w = LightDirection.x
	"uniform vec4 LightDataB;\n" //x = LightDirection.y, y = LightDirection.z, z = const, w = linear
	"uniform vec4 LightDataC;\n" //x = exp, y = LightPosition.x, z = LightPosition.y, w = LightPosition.z
	"uniform vec4 LightDataD;\n" //x = LightColor.r, y = LightColor.g, z = LightColor.b, w = LightType
	"uniform vec4 LightDataE;\n" //x = cutoff, y = outerCutoff, z = UNUSED, w = UNUSED
    "\n"
	"uniform sampler2D gDiffuseMap;\n"
	"uniform sampler2D gNormalMap;\n"
	"uniform sampler2D gMiscMap;\n"
	"uniform sampler2D gDepthMap;\n"
	"\n"
	"uniform vec4 ScreenData;\n" //x = near, y = far, z = winSize.x, w = winSize.y
	"uniform vec4 CamPosGamma;\n" //x = camX, y = camY, z = camZ, w = monitorGamma
	"uniform vec4 materials[MATERIAL_COUNT_LIMIT]; //r = frensel, g = specPower, b = specularModel, a = diffuseModel \n"
    "\n"
	"uniform mat4 VP;\n"
	"uniform mat4 invVP;\n"
	"\n"
	"vec3 reconstruct_world_pos(vec2 _uv){\n"
	"	float log_depth = texture2D(gDepthMap, _uv).r;\n"
	"	float regularDepth = pow(ScreenData.y + 1.0, log_depth) - 1.0; //log to regular depth\n"
    "\n"
	"	//linearize regular depth\n"
	"	float a = ScreenData.y / (ScreenData.y - ScreenData.x);\n"
	"	float b = ScreenData.y * ScreenData.x / (ScreenData.x - ScreenData.y);\n"
	"	float depth = (a + b / regularDepth);\n"
    "\n"
	"	//vec4 screenSpace = vec4(_uv * 2.0 - 1.0,depth,1.0);\n"
	"	vec4 screenSpace = (vec4(_uv,depth, 1.0) * 2.0 - 1.0);\n"
    "\n"
	"	//world space it!\n"
	"	vec4 wpos = invVP * screenSpace;\n"
	"	return wpos.xyz / wpos.w;\n"
	"}\n"
    "vec3 unpackColor(float f) {\n"
    "    vec3 color;\n"
    "    color.b = floor(f / 256.0 / 256.0);\n"
    "    color.g = floor((f - color.b * 256.0 * 256.0) / 256.0);\n"
    "    color.r = floor(f - color.b * 256.0 * 256.0 - color.g * 256.0);\n"
    "    // now we have a vec3 with the 3 components in range [0..255]. Let's normalize it!\n"
    "    return color / 255.0;\n"
    "}\n"
	"float BeckmannDist(float cos2a, float _alpha, float pi){\n"
	"	float b = (1.0 - cos2a) / (cos2a * _alpha);\n"
	"	return (exp(-b)) / (pi * _alpha * cos2a * cos2a);\n"
	"}\n"
	"float GGXDist(float NdotHSquared, float alphaSquared,float pi){\n"
	"	float nom   = alphaSquared;\n"
	"	float denom = (NdotHSquared * (alphaSquared - 1.0) + 1.0);\n"
	"	denom = pi * denom * denom;\n"
	"	return nom / denom;\n"
	"}\n"
	"float GeometrySchlickGGX(float NdotV, float roughness){\n"
	"	float k = (roughness*roughness) / 8.0;\n"
	"	float nom   = NdotV;\n"
	"	float denom = NdotV * (1.0 - k) + k;\n"
	"	return nom / denom;\n"
	"}\n"
	"vec3 SchlickFrensel(float cosTheta, vec3 frenselFactor){\n"
	"	vec3 ret = frenselFactor + (vec3(1.0) - frenselFactor) * pow( 1.0 - cosTheta, 5.0);\n"
	"	return ret;\n"
	"}\n"
	"vec3 CalcLightInternal(vec3 LightDir,vec3 PxlWorldPos,vec3 PxlNormal,vec2 uv){\n"
	"	float Glow = texture2D(gMiscMap,uv).r;\n"
	"	float SpecularStrength = texture2D(gMiscMap,uv).g;\n"
	"	vec3 MaterialAlbedoTexture = texture2D(gDiffuseMap,uv).rgb;\n"
	"	if((PxlNormal.r > 0.9999 && PxlNormal.g > 0.9999 && PxlNormal.b > 0.9999)){\n"
	"		return vec3(0.0);\n"
	"	}\n"
	"	vec3 LightAmbientColor  = LightDataD.xyz * LightDataA.x;\n"
	"	vec3 LightDiffuseColor  = LightDataD.xyz;\n"
	"	vec3 LightSpecularColor = LightDataD.xyz * SpecularStrength;\n"
	"	vec3 TotalLight         = vec3(0.0);\n"
	"\n"
	"	highp int index = int(texture2D(gNormalMap,uv).a);\n"
    "\n"
	"	vec3 SpecularFactor = vec3(0.0);\n"
    "\n"
	"	float kPi = 3.1415926535898;\n"
	"	float smoothness = materials[index].g;\n" //UNIFORM
    "\n"
	"	//vec3 F0 = unpackColor(materials[index].r);\n" //UNIFORM
	"	vec3 F0 = vec3(1.022,0.782,0.344);\n" //gold
	"	float metalness = texture2D(gMiscMap,uv).b;\n"
	"	F0 = mix(F0, MaterialAlbedoTexture, vec3(metalness));\n"
	"	vec3 Frensel = F0;\n"
    "\n"
	"	float roughness = 1.0 - smoothness;\n"
	"	float alpha = roughness * roughness;\n"
    "\n"
	"	vec3 ViewDir = normalize(CamPosGamma.xyz - PxlWorldPos);\n"
	"	vec3 Half = normalize(LightDir + ViewDir);\n"
	"	float NdotL = max(0.0, dot(PxlNormal, LightDir));\n"
	"	float NdotH = max(0.0, dot(PxlNormal, Half));\n"
	"	float VdotN = max(0.0, dot(ViewDir,PxlNormal));\n"
	"	float VdotH = max(0.0, dot(ViewDir,Half));\n"
    "\n"
	"	if(materials[index].a == 0.0){//this is lambert\n"
	"	}\n"
	"	else if(materials[index].a == 1.0){//this is oren-nayar\n"
	"		float thetaR = acos(VdotN);\n"
	"		float thetaI = acos(NdotL);\n"
	"		float A = 1.0 - 0.5 * (alpha / (alpha + 0.33));\n"
	"		float B = 0.45 * (alpha / (alpha + 0.09));\n"
	"		float gamma = dot(ViewDir - PxlNormal * VdotN, LightDir - PxlNormal * NdotL);\n"
	"		LightDiffuseColor *= (cos(thetaI)) * (A + (B * max(0.0,cos(gamma)) * sin(max(thetaI,thetaR)) * tan(min(thetaI,thetaR))));\n"
	"	}\n"
	"	else if(materials[index].a == 2.0){//this is ashikhmin-shirley\n"
	"		float s = clamp(smoothness,0.01,0.76);\n" //this lighting model has to have some form of roughness in it to look good. cant be 1.0
	"		vec3 A = (28.0 * MaterialAlbedoTexture) / vec3(23.0 * kPi);\n"
	"		//float B = (1.0 - (s * LightDataA.z));\n"
	"		float B = 1.0 - s;\n"
	"		float C = (1.0 - pow((1.0 - (NdotL / 2.0)),5.0));\n"
	"		float D = (1.0 - pow((1.0 - (VdotN / 2.0)),5.0));\n"
	"		LightDiffuseColor *= A * B * C * D;\n"
	"		LightDiffuseColor *= kPi;\n" //i know this isnt proper, but the diffuse component is *way* too dark otherwise...
	"	}\n"
	"	else if(materials[index].a == 3.0){//this is minneart\n"
	"		LightDiffuseColor *= pow(VdotN*NdotL,smoothness);\n"
	"	}\n"
	"\n"
	"	if(materials[index].b == 0.0){\n" // this is blinn phong (non-physical)
	"		float gloss = exp2(10.0 * smoothness + 1.0);\n"
	"		float kS = (8.0 + gloss ) / (8.0 * kPi);\n"
	"		//kS /= kPi;\n"
	"		SpecularFactor = vec3(kS * pow(NdotH, gloss));\n"
	"	}\n"
	"	else if(materials[index].b == 1.0){\n" //this is phong (non-physical)
	"		float gloss = exp2(10.0 * smoothness + 1.0);\n"
	"		float kS = (2.0 + gloss ) / (2.0 * kPi);\n"
	"		//kS /= kPi;\n"
	"		vec3 Reflect = reflect(-LightDir, PxlNormal);\n"
	"		float VdotR = max(0.0, dot(ViewDir,Reflect));\n"
	"		SpecularFactor = vec3(kS * pow(VdotR, gloss));\n"
	"	}\n"
	"	else if(materials[index].b == 2.0){\n" //this is GGX (physical)
	"		float LdotH = max(0.0, dot(LightDir,Half));\n"
	"		float alphaSqr = alpha * alpha;\n"
	"		float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0;\n"
	"		float D = alphaSqr / (kPi * denom * denom);\n"
	"		Frensel = SchlickFrensel(LdotH,F0);\n"
	"		float k = 0.5 * alpha;\n"
	"		float k2 = k * k;\n"
	"		SpecularFactor = max(vec3(0.0), (NdotL * D * Frensel / (LdotH*LdotH*(1.0-k2)+k2)) );\n"
	"	}\n"
	"	else if(materials[index].b == 3.0){\n" //this is Cook-Torrance (physical)
	"		Frensel = SchlickFrensel(VdotH,F0);\n"
	"		float NDF = GGXDist(NdotH*NdotH,alpha*alpha,kPi);\n"
	"		//float G = min(1.0, min(  (2.0 * NdotH * VdotN) / VdotH  ,  (2.0 * NdotH * NdotL) / VdotH  ));\n"
	"		float G = GeometrySchlickGGX(VdotN,roughness + 1.0) * GeometrySchlickGGX(NdotL,roughness + 1.0);\n"
	"		vec3 Top = NDF * Frensel * G;\n"
	"		float Bottom = max(4.0 * VdotN * NdotL,0.0);\n"
	"		SpecularFactor = Top / (Bottom + 0.0001);\n"
	"	}\n"
	"	else if(materials[index].b == 4.0){\n" //this is gaussian (physical)
	"		float b = acos(NdotH);\n" //this might also be cos. find out
	"		float fin = b / smoothness;\n"
	"		SpecularFactor = vec3(exp(-fin*fin));\n"
	"	}\n"
	"	else if(materials[index].b == 5.0){\n" //this is beckmann (physical)
	"		SpecularFactor = vec3(BeckmannDist(NdotH,alpha,kPi));\n"
	"	}\n"
	"	else if(materials[index].b == 6.0){\n" //this is ashikhmin-shirley (physical)
	"		//make these controllable uniforms\n"
	"		const float Nu = 1000.0;\n"
	"		const float Nv = 1000.0;\n"
    "\n"
	"		vec3 epsilon = vec3(1.0,0.0,0.0);\n"
	"		vec3 tangent = normalize(cross(PxlNormal,epsilon));\n"
	"		vec3 bitangent = normalize(cross(PxlNormal,tangent));\n"
	"		float hdotT = dot(Half,tangent);\n"
	"		float hDotB = dot(Half,bitangent);\n"
	"		float A = sqrt( (Nu + 1.0) * (Nv + 1.0) );\n"
	"		float B = pow(NdotH,((Nu * hdotT * hdotT + Nv * hDotB * hDotB) / (1.0 - (NdotH * NdotH)) ));\n"
	"		float HdotL = max(0.0, dot(Half, LightDir));\n"
	"		float C = 8.0 * kPi * HdotL * max(NdotL,VdotN);\n"
	"		SpecularFactor = vec3((A * B) / C);\n"
	"	}\n"
    "   LightDiffuseColor *= LightDataA.y;\n"
	"	LightSpecularColor *= (SpecularFactor * LightDataA.z);\n"
	"\n"
	"   vec3 kS = Frensel;\n"
	"	vec3 kD = vec3(1.0) - kS;\n"
	"	kD *= 1.0 - metalness;\n"
	"   vec3 FinalDiffuse = (kD * MaterialAlbedoTexture * LightDiffuseColor) / kPi;\n"
	"   vec3 FinalSpecular = LightSpecularColor;\n"
	"   TotalLight = (FinalDiffuse + FinalSpecular) * NdotL;\n"
	"	TotalLight += (LightAmbientColor * MaterialAlbedoTexture);\n"
	"	return max( vec3(Glow) * MaterialAlbedoTexture,TotalLight);\n"
	"}\n"
	"vec3 CalcPointLight(vec3 LightPos,vec3 PxlWorldPos, vec3 PxlNormal, vec2 uv){\n"
	"	vec3 LightDir = normalize(LightPos - PxlWorldPos);\n"
	"	float Dist = length(LightPos - PxlWorldPos);\n"
    "\n"
	"	vec3 c = CalcLightInternal(LightDir, PxlWorldPos, PxlNormal, uv);\n"
	"\n"
	"	float attenuation =  1.0 / (max(1.0 , LightDataB.z + (LightDataB.w * Dist) + (LightDataC.x * Dist * Dist)));\n"
	"	return c * attenuation;\n"
	"}\n"
	"vec3 CalcSpotLight(vec3 SpotLightDir, vec3 LightPos,vec3 PxlWorldPos, vec3 PxlNormal, vec2 uv){\n"
	"	vec3 LightDir = normalize(LightPos - PxlWorldPos);\n"
	"	vec3 c = CalcPointLight(LightPos, PxlWorldPos, PxlNormal, uv);\n"
	"	float cosAngle = dot(LightDir, -SpotLightDir);\n"
	"	float spotEffect = smoothstep(LightDataE.y, LightDataE.x, cosAngle);   \n"
	"	return c * spotEffect;\n"
	"}\n"
	"void main(void){\n"
	"	//vec2 uv = gl_TexCoord[0].st; //this cannot be used for point light mesh\n"
	"	vec2 uv = gl_FragCoord.xy / vec2(ScreenData.z,ScreenData.w);\n"
	"\n"
	"	vec3 PxlPosition = reconstruct_world_pos(uv);\n"
	"	vec3 PxlNormal = normalize(texture2D(gNormalMap, uv).rgb);\n"
	"\n"
	"	vec3 lightCalculation = vec3(0.0);\n"
	"	vec3 LightPosition = vec3(LightDataC.yzw);\n"
	"	vec3 LightDirection = normalize(vec3(LightDataA.w,LightDataB.x,LightDataB.y));\n"
	"\n"
	"	if(LightDataD.w == 0.0){\n"
	"		lightCalculation = CalcLightInternal(normalize(LightPosition - PxlPosition),PxlPosition,PxlNormal,uv);\n"
	"	}\n"
	"	else if(LightDataD.w == 1.0){\n"
	"		lightCalculation = CalcPointLight(LightPosition,PxlPosition,PxlNormal,uv);\n"
	"	}\n"
	"	else if(LightDataD.w == 2.0){\n"
	"		lightCalculation = CalcLightInternal(LightDirection,PxlPosition,PxlNormal,uv);\n"
	"	}\n"
	"	else if(LightDataD.w == 3.0){\n"
	"		lightCalculation = CalcSpotLight(LightDirection,LightPosition,PxlPosition,PxlNormal,uv);\n"
	"	}\n"
	"	gl_FragData[0].rgb = lightCalculation;\n"
	"}";

#pragma endregion

#endif
